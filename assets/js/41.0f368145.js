(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{392:function(a,t,e){"use strict";e.r(t);var r=e(45),s=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"function类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#function类型"}},[a._v("#")]),a._v(" Function类型")]),a._v(" "),e("p",[a._v("函数名是一个指向函数的指针，这也是没有重载的原因：新定义的同名函数会更改该函数名的引用。")]),a._v(" "),e("h2",{attrs:{id:"函数声明-函数表达式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数声明-函数表达式"}},[a._v("#")]),a._v(" 函数声明/函数表达式")]),a._v(" "),e("p",[a._v("这是一个函数声明：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function foo(bar){\n    return bar;\n}\n")])])]),e("p",[a._v("在代码执行之前，存在一个函数声明提升的过程，把所有的函数声明添加到执行环境中，因此在函数声明之前对其调用是没有问题的。"),e("br"),a._v("\n这是一个函数表达式：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let foo = function(bar){\n    return bar;\n};\n")])])]),e("p",[a._v("这时候没有提升过程，foo仅仅进行了初始化，在赋值之前调用会出现错误")]),a._v(" "),e("h2",{attrs:{id:"函数作为返回值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数作为返回值"}},[a._v("#")]),a._v(" 函数作为返回值")]),a._v(" "),e("p",[a._v("函数不仅可以作为参数传给另一个函数，也可以作为返回值被返回。一个例子：现有一个对象数组，我们需要根据对象中某一属性为数组排序。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("function compareBy(propertyName){\n    return function(object1, object2){\n        let val1 = object1[propertyName];\n        let val2 = object2[propertyName];\n        if(val1 > val2){\n            return 1;\n        }else{\n            return -1;\n        }\n    }\n}\n")])])]),e("p",[a._v("这时候就可以用sort方法进行排序了：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('let data = [\n    {\n        "name": "Nicholas",\n        "age": "29"\n    },\n    {\n        "name": "Zachary",\n        "age": "28"\n    }\n];\n\ndata.sort(compareBy("name"));\nconsole.log(data);\n\ndata.sort(compareBy("age"));\nconsole.log(data);\n')])])]),e("h2",{attrs:{id:"函数内部属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数内部属性"}},[a._v("#")]),a._v(" 函数内部属性")]),a._v(" "),e("h3",{attrs:{id:"arguments"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#arguments"}},[a._v("#")]),a._v(" arguments")]),a._v(" "),e("p",[a._v("保存着参数的类数组，还有一个callee属性，指向拥有此arguments对象的函数，可以用于递归时不借助函数名字进行调用。")]),a._v(" "),e("h3",{attrs:{id:"this"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[a._v("#")]),a._v(" this")]),a._v(" "),e("p",[a._v("调用函数的环境对象的引用")]),a._v(" "),e("h3",{attrs:{id:"caller"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#caller"}},[a._v("#")]),a._v(" caller")]),a._v(" "),e("p",[a._v("调用当前函数的函数的引用")]),a._v(" "),e("h2",{attrs:{id:"函数属性和方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#函数属性和方法"}},[a._v("#")]),a._v(" 函数属性和方法")]),a._v(" "),e("h3",{attrs:{id:"length"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#length"}},[a._v("#")]),a._v(" length")]),a._v(" "),e("p",[a._v("指示函数的参数个数")]),a._v(" "),e("h3",{attrs:{id:"prototype"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#prototype"}},[a._v("#")]),a._v(" prototype")]),a._v(" "),e("h3",{attrs:{id:"call和apply"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#call和apply"}},[a._v("#")]),a._v(" call和apply")]),a._v(" "),e("p",[a._v("apply有单独记录过，call与其类似，然而接收参数时必须将其一一列举"),e("br"),a._v("\n这两个方法真正强大之处在于能够扩充函数作用域，对象和方法不需要有任何的耦合关系，值得咀嚼：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('window.color = "red";\nlet o = {\n    color: "blue"\n};\n\nfunction getColor(){\n    return this.color;\n}\n\ngetColor.call(o);//得到blue\n\no.getColor();//也能得到blue，但是存在将函数放入o中这一多余的步骤\n')])])])])}),[],!1,null,null,null);t.default=s.exports}}]);