(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{379:function(e,t,r){"use strict";r.r(t);var a=r(45),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"fiber"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber"}},[e._v("#")]),e._v(" Fiber")]),e._v(" "),r("p",[e._v("fiber可以理解为一种工作单元的结构，它记录要工作的内容，并且便于随时暂停和继续工作")]),e._v(" "),r("p",[e._v("每个render方法内的JSX都会被转换为React.createElement，而React.createElement会为JSX的最外层元素设置为一个数据结构（比如就是一个span元素的JSX）：")]),e._v(" "),r("div",{staticClass:"language-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  $$"),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("typeof")]),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("Symbol")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("react"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("element"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  type"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[e._v("'span'")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n  key"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),e._v("\n  props"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n      children"),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n  "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])]),r("p",[e._v("$$typeof标识了一个react element，每一个react element都对应一个fiber")]),e._v(" "),r("ul",[r("li",[e._v("fiber就是一个对象结构，包含了一串需要完成的任务")]),e._v(" "),r("li",[e._v("每一个react element都对应一个fiber，element树就对应了fiber树")]),e._v(" "),r("li",[e._v("fiber不会在re-render过程中重新创建，它是可变的，保留了组件状态和dom")])]),e._v(" "),r("h2",{attrs:{id:"第一棵fiber树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第一棵fiber树"}},[e._v("#")]),e._v(" 第一棵fiber树")]),e._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js#L414",target:"_blank",rel:"noopener noreferrer"}},[e._v("createFiberFromTypeAndProps"),r("OutboundLink")],1),e._v("方法创建第一棵fiber树，之后就会重用fiber节点")]),e._v(" "),r("h2",{attrs:{id:"why-fiber"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#why-fiber"}},[e._v("#")]),e._v(" why fiber")]),e._v(" "),r("p",[e._v("使用fiber就是为了：")]),e._v(" "),r("ul",[r("li",[e._v("暂停任务，并且可以稍后继续")]),e._v(" "),r("li",[e._v("为不同的任务设置优先级")]),e._v(" "),r("li",[e._v("重用之前完成过的任务")]),e._v(" "),r("li",[e._v("终止不再需要的任务")])]),e._v(" "),r("h2",{attrs:{id:"原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),r("p",[e._v("react15时还没有fiber结构，调和过程是树的递归，会使用大量调用栈，而且持续占用主线程。")]),e._v(" "),r("p",[e._v("fiber树就是一个偏线性的结构，它的主体是一个单链表，沿着链表检查fiber节点避免了递归这样不能中断的操作，并且根据是否有时间执行下一个任务来判断是否需要归还主线程。")]),e._v(" "),r("h2",{attrs:{id:"fiber-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber-tree"}},[e._v("#")]),e._v(" fiber tree")]),e._v(" "),r("p",[e._v("fiber树的父节点只和第一个子节点通过child引用相连，同级兄弟节点通过sibling引用相连，每个兄弟节点都有一个return引用指向父节点。")]),e._v(" "),r("p",[e._v("两颗fiber树（current和wIP）的节点之间应该是有对应的引用的")]),e._v(" "),r("p",[e._v("节点大概有这些关键属性：")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("{\n    stateNode, // 引用此fiber节点对应的DOM节点，组件，其它fiber节点\n    child,\t// 子节点\n    return,\t// effect列表通过return引用回传给上级节点\n    sibling, \n    key,\n    effectTag, // 副作用类型，新增，更新，删除，移动等，例如PLACEMENT表示新增节点\n    nextEffect, // 很重要，react通过这个找到下一个effect工作\n    firstEffect,\n}\n")])])]),r("h3",{attrs:{id:"遍历fiber-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#遍历fiber-tree"}},[e._v("#")]),e._v(" 遍历fiber tree")]),e._v(" "),r("ol",{attrs:{start:"0"}},[r("li",[e._v("把当前遍历节点作为a")]),e._v(" "),r("li",[e._v("完成a节点需要做的任务")]),e._v(" "),r("li",[e._v("是否有a.child")]),e._v(" "),r("li",[e._v("有a.child，把a.child作为a，回到1")]),e._v(" "),r("li",[e._v("为空，则判断是否有a.sibling，如有，将a.sibling作为a，回到1")]),e._v(" "),r("li",[e._v("如果没有，也就是a.child和a.sibling都没有了，就认为当前这一层的节点都遍历过了，那就返回父节点寻找sibling，如果父节点有sibling，将其作为a，回到1")]),e._v(" "),r("li",[e._v("如果已经到根结点了，就结束")])]),e._v(" "),r("p",[e._v("补充：第一步“完成该节点的任务”不够明确，其实是执行beginWork方法，它根据原本的fiber节点创建新的fiber（因为这个过程实际上就是在构建wIP树，最好结合下面的一起理解）。另外还有一个completeWork方法，发生在第四步中，在前往a.sibling之前，会执行completeWork方法，收集当前节点的副作用交给父级fiber节点，然后再前往兄弟节点从第一步开始")]),e._v(" "),r("h2",{attrs:{id:"构建workinprogress-fiber-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#构建workinprogress-fiber-tree"}},[e._v("#")]),e._v(" 构建workInProgress fiber tree")]),e._v(" "),r("p",[e._v("复用current fiber tree，构建workInProgress fiber tree")]),e._v(" "),r("ol",[r("li",[e._v("如果当前节点不需要更新，就直接把节点复制过来，并转到5；需要更新则在tag属性上进行标记")]),e._v(" "),r("li",[e._v("更新当前节点的状态（props，state，context等）")]),e._v(" "),r("li",[e._v("调用shouldComponentUpdate，如果是false，转到5")]),e._v(" "),r("li",[e._v("调用render获取新的子节点，从现有的fiber节点为它创建一个新的fiber节点")]),e._v(" "),r("li",[e._v("如果没有产生child fiber节点，那么本节点的工作就结束了，effect list被交给return引用的父节点，下一个工作节点将会是当前节点的sibling。如果产生了child fiber节点，那么产生的这个节点就是下一个工作节点")]),e._v(" "),r("li",[e._v("检查剩余可用时间，如果有空就开始下一个工作节点的任务，否则等待主线程空闲")]),e._v(" "),r("li",[e._v("如果没有下一个工作节点，（此时已经返回了fiber树的根节点，wIP树构建完成）进入pendingCommit状态")])]),e._v(" "),r("p",[e._v("结束后，根结点的effect list就保存着完整的effect list fiber tree，所有effect工作就会被连在一起，这样react在执行这些effect工作的时候就可以跳过其它的节点")]),e._v(" "),r("h2",{attrs:{id:"effect"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#effect"}},[e._v("#")]),e._v(" Effect")]),e._v(" "),r("p",[e._v("就是处理更新之外还需要完成的工作，例如修改DOM")]),e._v(" "),r("h2",{attrs:{id:"fiber树根"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#fiber树根"}},[e._v("#")]),e._v(" fiber树根")]),e._v(" "),r("p",[e._v("对fiber树的引用可以通过react根元素的DOM引用找到：")]),e._v(" "),r("div",{staticClass:"language-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" fiberRoot "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token function"}},[e._v("query")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),r("span",{pre:!0,attrs:{class:"token string"}},[e._v("'#container'")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("_reactRootContainer"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("_internalRoot\n\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" hostRootFiberNode "),r("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" fiberRoot"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("current\n")])])]),r("h2",{attrs:{id:"双缓冲"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双缓冲"}},[e._v("#")]),e._v(" 双缓冲")]),e._v(" "),r("p",[e._v("就是wIP树构造完毕，就会成为新的current fiber tree，旧的current tree就不再引用了（被回收）。这样复用了一整颗树")])])}),[],!1,null,null,null);t.default=s.exports}}]);