(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{420:function(n,e,t){"use strict";t.r(e);var a=t(45),s=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[n._v("#")]),n._v(" this")]),n._v(" "),t("p",[n._v("在闭包中使用this也可能导致一些问题。this是在运行时基于函数执行环境绑定的：全局函数中，this等于window，而当函数被作为某个方法调用当时候，this等于那个对象。不过，匿名函数的执行环境具有全局性，它的this通常指向window，但是由于有些时候编写闭包当方式不同，这一点可能不会那么明显。一个例子：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('var name = "The Window";\n\nvar object = {\n    name : "My Object",\n\n    getNameFunc: function(){\n        return function(){\n            return this.name;\n        };\n    }\n};\n\nalert(object.getNameFunc()());  // The Window \n\n//上述代码相当于下面的实现：\n\nvar name = "The Window";\nfunction getThisName(){\n    return this.name\n}\nvar object = {\n    name: "My Object",\n    getNameFunc: function() {\n        return getThisName\n    }\n};\nvar getThisNameFunc = object.getNameFunc()\nconsole.log(getThisNameFunc()); \n\n//getThisName这个被抽离出来的命名函数就相当于之前的匿名函数，它和object的定义没有任何关系，只是 object.getNameFunc 这个函数将这个函数作为返回值。如果是返回的其他标量，自然也不会发生关系。\n')])])]),t("p",[n._v("上述代码拥有一个全局变量name和一个包含name属性的对象，这个对象还有一个方法，返回一个返回this.name的匿名函数。由于getNameFunc返回一个函数，因此调用object.getNameFunc()()就会立即调用这个被返回的函数，结果就是返回一个字符串。然而，它返回了全局的name值，这是为什么呢？之前提到过，匿名函数的执行环境具有全局性，它在搜索变量的时候，只会搜索到它的活动对象，因此外部的name值会被先找到。\n观察第二种实现并进行理解，匿名函数的this就是全局的this。\n把外部作用域的this值保存在一个闭包能访问到的变量里，就可以让闭包访问到该对象了：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('var name = "The Window";\n\nvar object = {\n    name : "My Object",\n\n    getNameFunc: function(){\n        var that = this;\n        return function(){\n            return that.name;\n        };\n    }\n};\n\nalert(object.getNameFunc()());  // My Object\n\n')])])]),t("p",[n._v("that是闭包可以访问到的变量，即使函数返回了，that仍然引用object，方法总能返回object的name。\n这时候能够感受到js的动态之处，静态语言的this大多在写下代码的地方就已经确定了，而js的this是在方法执行时才获取。\n特殊情况下，this的值会出现不同，例如下面的修改代码：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('var name = "The Window";\n\nvar object = {\n    name : "My Object",\n\n    getNameFunc: function(){\n        return this.name;\n    }\n};\n')])])]),t("p",[n._v("这里的方法简单地返回this.name。以下是几种调用方法及结果")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("object.getName();  //My Object\n(object.getName)();  //My Object\n(object.getName = object.getName)();  //The Window\n")])])]),t("p",[n._v("第三行先执行了一个赋值语句，再调用赋值之后的结果，this的值不能得到维持，返回了The Window（不是特别理解，找了一篇"),t("a",{attrs:{href:"https://segmentfault.com/a/1190000011490347",target:"_blank",rel:"noopener noreferrer"}},[n._v("文章"),t("OutboundLink")],1),n._v("）")])])}),[],!1,null,null,null);e.default=s.exports}}]);