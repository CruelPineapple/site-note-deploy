(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{381:function(a,t,e){"use strict";e.r(t);var n=e(45),r=Object(n.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"信息流分页展示"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#信息流分页展示"}},[a._v("#")]),a._v(" 信息流分页展示")]),a._v(" "),e("p",[a._v("翻页之后会需要回到顶部，直接设置scrollTop的值过于突兀")]),a._v(" "),e("h2",{attrs:{id:"requestanimationframe-callback"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#requestanimationframe-callback"}},[a._v("#")]),a._v(" requestAnimationFrame(callback)")]),a._v(" "),e("p",[a._v("这个方法将会通知浏览器，在下一次重绘的时候执行callback函数调用动画"),e("br"),a._v("\n要实现动画效果，需要callback自身再次调用requestAnimationFrame"),e("br"),a._v("\n这里借助回到顶部的动画demo说明")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("  let timer = null;//用于接收返回ID，通过ID可以调用cancelAnimationFrame\n\n  cancelAnimationFrame(timer);\n  timer = requestAnimationFrame(function fn() {\n    var oTop =\n      document.body.scrollTop || document.documentElement.scrollTop;\n      //获取距离顶部的px值\n\n    if (oTop > 0) {\n      //若不在顶部则向上移动90px\n      document.body.scrollTop = document.documentElement.scrollTop =\n        oTop - 90;\n      //再次调用自身实现持续动画\n      timer = requestAnimationFrame(fn);\n    } else {\n      //否则终止动画\n      cancelAnimationFrame(timer);\n    }\n")])])]),e("p",[a._v("上述demo实现了每帧滚动90px直到回到顶部的功能"),e("br"),a._v("\nrequestAnimationFrame方法相比setTimeout更适合用于动画绘制，因为它不指定绘制间隔，由浏览器按照显示情况决定。")]),a._v(" "),e("h2",{attrs:{id:"实际情况采用增长信息流的方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实际情况采用增长信息流的方式"}},[a._v("#")]),a._v(" 实际情况采用增长信息流的方式")]),a._v(" "),e("p",[a._v("在信息流底部设置点击查看更多的区域，调用功能类似翻页，但是不会将接口获取的数据直接用于列表渲染，而是将其内容加入列表渲染数组的尾部，实现信息流增长：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('    //仅展示then中内容\n        .then((res) => {\n          if (res.data.code == 0) {\n            let newArr = res.data.data;\n            for(let i = 0; i < newArr.length; i++){\n              this.render.push(newArr[i]);\n            }\n            this.loading = false;\n          } else {\n            this.$message("获取推送失败，msg：" + res.data.msg);\n          }\n        });    \n')])])]),e("h2",{attrs:{id:"数组拼接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组拼接"}},[a._v("#")]),a._v(" 数组拼接")]),a._v(" "),e("h2",{attrs:{id:"concat-arr1-arr2-原生方法-会按参数顺序把数组拼起来-不改变原数组们-返回一个新的数组如果考虑到节省内存空间-在原有数组上拼接-使用for循环遍历就行了"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#concat-arr1-arr2-原生方法-会按参数顺序把数组拼起来-不改变原数组们-返回一个新的数组如果考虑到节省内存空间-在原有数组上拼接-使用for循环遍历就行了"}},[a._v("#")]),a._v(" concat(arr1, arr2, ...)"),e("br"),a._v("\n原生方法，会按参数顺序把数组拼起来，不改变原数组们，返回一个新的数组"),e("br"),a._v("\n如果考虑到节省内存空间，在原有数组上拼接，使用for循环遍历就行了")]),a._v(" "),e("p",[e("strong",[a._v("Function.prototype.apply()")]),e("br"),a._v("\napply方法接收两个参数，第一个用于指定为function的this值，第二个是参数数组，数组的元素会挨个作为函数的参数传入：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("let a = [1, 2, 3];\na.push.apply(a,[4,5,6]);\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);