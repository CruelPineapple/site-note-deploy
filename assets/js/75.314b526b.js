(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{432:function(t,e,a){"use strict";a.r(e);var r=a(45),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"regexp类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#regexp类型"}},[t._v("#")]),t._v(" RegExp类型")]),t._v(" "),a("h2",{attrs:{id:"创建正则表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建正则表达式"}},[t._v("#")]),t._v(" 创建正则表达式")]),t._v(" "),a("p",[t._v("pattern指示需要匹配的字符串，flags指定匹配模式，模式有g，i，m三种，分别是匹配全部模式（而不是仅匹配首个）；不区分大小写模式；换行模式（到达行尾也会继续匹配下一行）。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('let expression = / pattern / flags;\n\nlet exp1 = /at/g;  //匹配所有“at”  \nlet exp2 = /[bc]at/i;  //匹配首个“bat”或“cat”，不区分大小写\nlet exp3 = /.at/gi;  //匹配所有以at结尾的3字符组合，不区分大小写\n\n//用构造函数创建正则表达式\nlet exp4 = new RegExp("[bc]at","i");  //与exp2相同\n')])])]),a("p",[t._v("需要注意使用构造函数时，参数为字符串，存在二次转义的问题，即原本pattern中的\\转义符在字符串中需要被再次转义为\\，不然就变成字符串字面量了")]),t._v(" "),a("h2",{attrs:{id:"exec"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#exec"}},[t._v("#")]),t._v(" exec")]),t._v(" "),a("p",[t._v("RegExp对象的主要方法，接受一个参数，即要应用匹配模式的字符串，返回一个数组，第一项是完全匹配的内容，后续每项是每个分组捕获匹配的内容。同时，此RegExp对象的lastIndex属性记录了下一次匹配的起点。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('// Match "quick brown" followed by "jumps", ignoring characters in between\n// Remember "brown" and "jumps"\n// Ignore case\nvar re = /quick\\s(brown).+?(jumps)/ig;\nvar result = re.exec(\'The Quick Brown Fox Jumps Over The Lazy Dog\');\n')])])]),a("p",[t._v("result:")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("属性/索引")]),t._v(" "),a("th",[t._v("描述")]),t._v(" "),a("th",[t._v("例子")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("[0]")]),t._v(" "),a("td",[t._v("匹配的全部字符串")]),t._v(" "),a("td",[t._v("Quick Brown Fox Jumps")])]),t._v(" "),a("tr",[a("td",[t._v("[1], ...[n ]")]),t._v(" "),a("td",[t._v("括号中的分组捕获")]),t._v(" "),a("td",[t._v("[1] = Brown [2] = Jumps")])]),t._v(" "),a("tr",[a("td",[t._v("index")]),t._v(" "),a("td",[t._v("匹配到的字符位于原始字符串的基于0的索引值")]),t._v(" "),a("td",[t._v("4")])]),t._v(" "),a("tr",[a("td",[t._v("input")]),t._v(" "),a("td",[t._v("原始字符串")]),t._v(" "),a("td",[t._v("The Quick Brown Fox Jumps Over The Lazy Dog")])])])]),t._v(" "),a("h2",{attrs:{id:"test"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test"}},[t._v("#")]),t._v(" test")]),t._v(" "),a("p",[t._v("test方法仅返回布尔值，判断传入字符串是否存在匹配的模式")])])}),[],!1,null,null,null);e.default=s.exports}}]);