(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{390:function(e,t,a){"use strict";a.r(t);var r=a(45),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[e._v("#")]),e._v(" 生命周期")]),e._v(" "),a("p",[e._v("总结一下声明周期，通过几个钩子来系统地描述")]),e._v(" "),a("p",[e._v("生命周期钩子有这么几个：beforeCreate，created，beforeMount，mounted，beforeUpdate，updated，beforeDestroy，destroyed。文档里面的"),a("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA",target:"_blank",rel:"noopener noreferrer"}},[e._v("图"),a("OutboundLink")],1),e._v("就很清楚地描述了它们的关系，这里做出我自己的总结。")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("本篇在阅读时需要稍微注意，标题是钩子名称但是内容其实是这个钩子之前发生的事情。")])]),e._v(" "),a("h2",{attrs:{id:"更新顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新顺序"}},[e._v("#")]),e._v(" 更新顺序")]),e._v(" "),a("p",[e._v("这个顺序更多的是钩子触发顺序，实际上每个步骤的工作内容还需要进一步理解")]),e._v(" "),a("h3",{attrs:{id:"渲染过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程"}},[e._v("#")]),e._v(" 渲染过程：")]),e._v(" "),a("p",[e._v("只要理解，子组件是在挂载阶段初始化的就行，在子组件挂载完成后父组件才能完成挂载。我的理解是，父组件得把挂载工作做好才能让子组件挂载（不然子组件往哪挂），只是mounted钩子得子组件mounted了才触发")]),e._v(" "),a("p",[e._v("父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted")]),e._v(" "),a("h3",{attrs:{id:"子组件更新"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#子组件更新"}},[e._v("#")]),e._v(" 子组件更新：")]),e._v(" "),a("p",[e._v("父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated")]),e._v(" "),a("h2",{attrs:{id:"异步请求"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步请求"}},[e._v("#")]),e._v(" 异步请求")]),e._v(" "),a("p",[e._v("没看源码，但是据说，created和mounted钩子里面进行异步请求是没有区别的，这两个钩子是在同一个tick里面执行的，而ajax请求的时间一定会超过一个tick，即便耗时0ms，那也是在nextTick中更新数据到DOM")]),e._v(" "),a("h2",{attrs:{id:"beforecreate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beforecreate"}},[e._v("#")]),e._v(" beforeCreate")]),e._v(" "),a("p",[e._v("这是第一个钩子，在这个钩子之前，vue合并了用户传给Vue构造函数的所有参数，进行实例初始化，确认父子组件关系，初始化组件的方法，挂在将render函数转换为vnode的方法。")]),e._v(" "),a("p",[e._v("这时候是不能通过this访问data中的变量的，因为data中的变量还没有被挂载到this上。beforeCreate在开发中使用较少（确实），而插件内部的install方法通过Vue.use安装的时候一般会选用这个钩子，因为这时候已经可以访问到vue实例，可以进行必要的初始化")]),e._v(" "),a("h2",{attrs:{id:"created"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#created"}},[e._v("#")]),e._v(" created")]),e._v(" "),a("p",[e._v("第二个钩子，beforeCreate触发后，vue进行了inject和provide初始化（没接触过，好像是和依赖相关的），以及State初始化，包括props，methods，data，computed和watch。state初始化就是把props，methods，data挂载到this上，computed属性添加watcher（后两个state查的不深）。")]),e._v(" "),a("p",[e._v("created之后就能使用this访问data了。但是注意，methods里面不能使用箭头函数，methods方法里的this自动绑定为vue实例，箭头函数绑定的是执行上下文，没有指向vue实例。")]),e._v(" "),a("h2",{attrs:{id:"beforemount"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beforemount"}},[e._v("#")]),e._v(" beforeMount")]),e._v(" "),a("p",[e._v("第三个钩子，created触发后，会判断传给构造函数的参数中是否存在el选项，如果不存在就停止编译了，直到在这个实例上调用vm$mount(el)。然后判断template参数，如果有template选项，则这个实例会被作为模板编译成render函数，没有的话就把外部html作为模板来编译。先判断el就是为了让这一步能找到外部html。vue对象里面还有个render选项，在这个里面创建的元素是优先级最高的，其次是template，最后是外部html")]),e._v(" "),a("h2",{attrs:{id:"mounted"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mounted"}},[e._v("#")]),e._v(" mounted")]),e._v(" "),a("p",[e._v("beforeMount触发后，vue实例被添加$el成员，并且替换掉el。其实不太明白这是个什么意思，这时候应该是把DOM元素都渲染好了吧，可能就是拿真正的元素节点替换了el，el代表要挂载的目标节点？这时候可以通过vm.$el访问el。")]),e._v(" "),a("p",[e._v("有一个细节，beforeMount触发后，this.$el拿到的虽然是dom元素，但是内部的表达式还是通过mustache进行占位的，直到mounted之后才会变成data中的内容，或许可以帮助理解。也就是说，mounted之后才正式可以访问DOM")]),e._v(" "),a("h2",{attrs:{id:"更新钩子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更新钩子"}},[e._v("#")]),e._v(" 更新钩子")]),e._v(" "),a("p",[e._v("beforeUpdate触发时，实例还没有任何更新动作，触发后，进行虚拟DOM重绘和并修改DOM变化的部分，最后触发updated")]),e._v(" "),a("h2",{attrs:{id:"beforedestroy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#beforedestroy"}},[e._v("#")]),e._v(" beforeDestroy")]),e._v(" "),a("p",[e._v("很好理解，就是销毁之前触发，这时候实例还完好无损")]),e._v(" "),a("h2",{attrs:{id:"destroyed"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#destroyed"}},[e._v("#")]),e._v(" destroyed")]),e._v(" "),a("p",[e._v("beforeDestroy触发后，实例的watcher，子组件和监听器都会被解除，解除完毕后触发destroyed")])])}),[],!1,null,null,null);t.default=s.exports}}]);