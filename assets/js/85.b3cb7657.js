(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{438:function(t,a,e){"use strict";e.r(a);var r=e(45),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"http方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http方法"}},[t._v("#")]),t._v(" HTTP方法")]),t._v(" "),e("h2",{attrs:{id:"get方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#get方法"}},[t._v("#")]),t._v(" GET方法")]),t._v(" "),e("p",[t._v("语义是从url请求资源，一般使用url参数，所以参数也只能进行url编码，必须是ASCII字符，同时长度也有限制。另外，Get请求的内容是可以被历史记录和浏览器书签保存的，且会被浏览器缓存（HTTP缓存）")]),t._v(" "),e("h2",{attrs:{id:"post方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#post方法"}},[t._v("#")]),t._v(" POST方法")]),t._v(" "),e("p",[t._v("语义是将数据发送到服务器来创建资源。post参数在请求体中，它不会被缓存，也不会被留在历史记录中，也没有参数长度和编码限制")]),t._v(" "),e("h3",{attrs:{id:"和get区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#和get区别"}},[t._v("#")]),t._v(" 和get区别")]),t._v(" "),e("p",[t._v("get和post的一些比较基础的区别是在用法上：")]),t._v(" "),e("p",[t._v("get使用url参数而post请求内容在请求体内")]),t._v(" "),e("p",[t._v("get只能进行url编码（application/x-www-form-urlencoded），post能进行多种编码（application/x-www-form-urlencoded 或 multipart/form-data）")]),t._v(" "),e("p",[t._v("get参数只支持ASCII字符，限制长度（最大2048），post参数没有限制")]),t._v(" "),e("p",[t._v("get与post相比安全性更差，因为数据是url的一部分")]),t._v(" "),e("p",[t._v("但是说是get没有请求体，那也只是规定，实际上可以给get增加请求体，也能让post使用url参数，这都不是绝对的，只是一般大家不会这么干。")]),t._v(" "),e("p",[t._v("看到一篇文章说post会发送两个tcp数据包而get只发送一个，感觉很奇怪，查了一下发现有人也对这篇文章感到疑惑，貌似是关于语言框架的问题，故意分成两个包发的，而且是请求头和请求体分开发，没有超过tcp的包大小限制。")]),t._v(" "),e("p",[t._v("所以没有post一定要分成两个tcp包的说法，大多数http框架都会尽量用一个tcp包发完。")]),t._v(" "),e("h2",{attrs:{id:"put"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#put"}},[t._v("#")]),t._v(" PUT")]),t._v(" "),e("p",[t._v("语义是将数据发送到服务器更新已有资源，与POST相比，PUT是幂等方法，多次相同的PUT会产生相同的结果，但是POST会创建多个一样的资源")]),t._v(" "),e("h2",{attrs:{id:"head"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#head"}},[t._v("#")]),t._v(" HEAD")]),t._v(" "),e("p",[t._v("与GET相同，但是没有返回的响应主体，例如GET会请求到一个用户列表，那么HEAD就会发出同样的请求但是不会返回用户列表。用于实际发送GET请求之前检查GET请求将要返回的内容（例如下载大文件或者较大的响应正文的场景）")]),t._v(" "),e("h2",{attrs:{id:"delete"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#delete"}},[t._v("#")]),t._v(" DELETE")]),t._v(" "),e("p",[t._v("语义是删除url所指示的资源")]),t._v(" "),e("h2",{attrs:{id:"option"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#option"}},[t._v("#")]),t._v(" OPTION")]),t._v(" "),e("p",[t._v("另一个类似的情况是跨域处理中的OPTION请求，会先进行预请求")])])}),[],!1,null,null,null);a.default=s.exports}}]);