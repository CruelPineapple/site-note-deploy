(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{474:function(t,_,v){"use strict";v.r(_);var e=v(45),l=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"自我介绍"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#自我介绍"}},[t._v("#")]),t._v(" 自我介绍")]),t._v(" "),v("p",[t._v("电子科技大学大三，软件工程，大一接触前端，目前持续在学习前端相关的知识")]),t._v(" "),v("h2",{attrs:{id:"过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#过程"}},[t._v("#")]),t._v(" 过程")]),t._v(" "),v("p",[t._v("大一开始看视频了解html和css，入门了js，浅看红宝书前7章。开始接触项目，从原生js到框架（vue），后续接触组件库和工具库。另外也有做过几个小程序项目。大二下学期经过一次面试之后了解到自己的不足，开始细看红宝书，了解es6，开始了解框架原理（vue），接触react和nodejs（练习项目）")]),t._v(" "),v("h2",{attrs:{id:"网络"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络"}},[t._v("#")]),t._v(" 网络")]),t._v(" "),v("ul",[v("li",[t._v("三次握手四次挥手")]),t._v(" "),v("li",[t._v("跨域")]),t._v(" "),v("li",[t._v("Http请求（get，post，restful）")]),t._v(" "),v("li",[t._v("Http2，Https")]),t._v(" "),v("li",[t._v("Http缓存")]),t._v(" "),v("li",[t._v("TCP拥塞控制")])]),t._v(" "),v("h2",{attrs:{id:"js目录"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#js目录"}},[t._v("#")]),t._v(" JS目录")]),t._v(" "),v("ul",[v("li",[t._v("7个基本类型：数值，布尔，字符串，null，undefined，symbol，bigint")]),t._v(" "),v("li",[t._v("基本包装类型（String，Number，String）便于调用基本数据类型的方法，调用完了就销毁")]),t._v(" "),v("li",[t._v("ES6特性\n"),v("ul",[v("li",[t._v("let/const，块级作用域")]),t._v(" "),v("li",[t._v("箭头函数：this绑定词法作用域（在原型上添加方法不能用箭头函数）")]),t._v(" "),v("li",[t._v("类语法：继承的语法糖\n"),v("ul",[v("li",[t._v("super通过组合继承完成静态属性绑定")]),t._v(" "),v("li",[t._v("extend通过寄生继承指定实例原型的形式完成方法继承")]),t._v(" "),v("li",[t._v("static静态方法不会挂载到原型，而是直接挂载在实例")])])]),t._v(" "),v("li",[t._v("增强对象字面量：直接使用变量/函数名作为属性和方法，getter和setter")]),t._v(" "),v("li",[t._v("Map和Set\n"),v("ul",[v("li",[t._v("Map：set，get，has，delete，size，for of 迭代的时候按插入的顺序")]),t._v(" "),v("li",[t._v("Set：add，has，delete，size，for of 也是按插入顺序")])])]),t._v(" "),v("li",[t._v("WeakMap，WeakSet\n"),v("ul",[v("li",[t._v("WeakMap只能把对象引用作为key，它不能迭代")]),t._v(" "),v("li",[t._v("WeakSet只能储存对象引用，不能遍历")]),t._v(" "),v("li",[t._v("垃圾回收的时候不会考虑它们的引用")])])]),t._v(" "),v("li",[t._v("模板字符串")]),t._v(" "),v("li",[t._v("其它：剩余参数，扩展运算符，解构赋值，Proxy，Reflect，Symbol")])])]),t._v(" "),v("li",[t._v("闭包")]),t._v(" "),v("li",[t._v("判断类型的方法\n"),v("ul",[v("li",[t._v("tyoepf 判断基本类型信息，以及函数和对象")]),t._v(" "),v("li",[t._v("instanceof 左边的值是不是右边的实例")]),t._v(" "),v("li",[t._v("Object.prototype.toString.call 对象的内部类型")])])]),t._v(" "),v("li",[t._v("Object.prototype.hasOwnProperty.call 用这个确定属性是自己的还是原型链上的")]),t._v(" "),v("li",[t._v("原型链\n"),v("ul",[v("li",[t._v("每个js对象（除了null）都有一个原型（_proto_)")]),t._v(" "),v("li",[t._v("prototype是函数的原型对象，这个函数作为构造函数使用的时候，prototype会成为生成的实例的原型（_proto_)")]),t._v(" "),v("li",[t._v("把一个对象的原型设置为另一个对象，就把另一个对象的原型上的东西也继承到了")]),t._v(" "),v("li",[t._v("函数._proto_ === Function.prototype: Function是所有函数的构造函数")]),t._v(" "),v("li",[t._v("Function._proto_ === Function.prototype：Function也是函数")]),t._v(" "),v("li",[t._v("实例对象._proto_===构造函数.prototype")]),t._v(" "),v("li",[t._v("Object._proto_===Function.prototype：Object也是函数")]),t._v(" "),v("li",[t._v("Object.prototype._proto_===null：原型链的终点")])])]),t._v(" "),v("li",[t._v("instanceOf原理：不停地取左值的_proto_，每次将其与右值的prototype比较")]),t._v(" "),v("li",[t._v("消息队列和事件循环")]),t._v(" "),v("li",[t._v("v8模型")])])])}),[],!1,null,null,null);_.default=l.exports}}]);