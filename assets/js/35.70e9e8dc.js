(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{390:function(e,n,t){"use strict";t.r(n);var a=t(45),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"其他继承方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他继承方式"}},[e._v("#")]),e._v(" 其他继承方式")]),e._v(" "),t("h2",{attrs:{id:"原型式继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型式继承"}},[e._v("#")]),e._v(" 原型式继承")]),e._v(" "),t("p",[e._v("借助原型可以通过已有对象创建新的对象：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function object(o){\n    function F(){};\n    F.prototype = o;\n    return new F();\n}\n")])])]),t("p",[e._v("使用临时的构造函数制作一个临时类型的实例。ES5提供Object.create()规范化原型式继承，两个参数，第一个就是上例的o，第二个是为新对象定义额外属性的对象。")]),e._v(" "),t("h2",{attrs:{id:"寄生式继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#寄生式继承"}},[e._v("#")]),e._v(" 寄生式继承")]),e._v(" "),t("p",[e._v("创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再享受真的做了所有工作一样返回对象：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function createAnother(original){\n    var clone = object(original); // 用上例的object创建一个新对象\n    clone.sayHi = function(){ // 增强这个对象\n        alert("hi");\n    };\n    return clone; // 返回它\n}\n\nvar person = {\n    name: "Nicholas",\n    friends: ["Shelby", "Court", "Van"]\n};\n\nvar anotherPerson = createAnother(person);\nanotherPerson.sayHi()\n')])])]),t("h2",{attrs:{id:"寄生组合式继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#寄生组合式继承"}},[e._v("#")]),e._v(" 寄生组合式继承")]),e._v(" "),t("p",[e._v("js最常用的组合继承模式始终会调用两次超类构造函数：一次是创建子类型原型的时候，另一次是子类型构造函数内部。就是说，子类型始终会包含超类对象全部实例属性，然后我们在子类构造函数调用时不得不重写它们，例如：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function SuperType(name){\n    this.name = name;\n    this.colors = ["red", "blue", "green"];\n}\n\nSuperType.prototype.sayName = function(){\n    alert(this.name);\n}\n\nfunction SubType(name, age){\n    SuperType.call(this.name); // 第二次调用SuperType\n\n    this.age = age;\n}\n\nSubType.prototype = new SuperType(); // 第一次调用SuperType\nSubType.prototype.sayAge = function(){\n    alert(this.age);\n};\n\n')])])]),t("p",[e._v("通过借用构造函数来继承属性,通过原型链的混成形式来继承方法：不必为了指定子类型的原型二调用超类的构造函数，我们需要的无非就是超类原型的一个副本。基本模式如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function inheritPrototype(subType, superType){\n    var prototype = object(superType.prototype);\n    prototype.constructor = subType;\n    subType.prototype = prototype\n}\n")])])]),t("p",[e._v("第一步是创建超类型原型的一个副本，第二步是为创建的副本添加constructor属性，从而弥补因重写原型而失去的默认constructor，最后一步将新创建的对象赋给子类型的原型。具体用例：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function SuperType(name){\n    this.name = name;\n    this.colors = ["red", "blue", "green"];\n}\n\nSuperType.prototype.sayName = function(){\n    alert(this.name);\n}\n\nfunction SubType(name, age){\n    SuperType.call(this.name); \n\n    this.age = age;\n}\n\ninheritPrototype(SubType, SuperType);\n// 代替之前为子类原型赋值的语句\n\nSubType.prototype.sayAge = function(){\n    alert(this.age);\n};\n')])])]),t("p",[e._v("寄生式组合继承被普遍认为是引用类型最理想的继承范式！")])])}),[],!1,null,null,null);n.default=r.exports}}]);