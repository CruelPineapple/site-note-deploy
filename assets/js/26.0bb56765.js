(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{379:function(t,a,s){"use strict";s.r(a);var e=s(45),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"使用mounted失误"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用mounted失误"}},[t._v("#")]),t._v(" 使用mounted失误")]),t._v(" "),s("p",[t._v("今天(21-5-6)甲方反应了一个bug，高校交友项目的学历信息没有随搜索变化。一开始我以为是后台数据库查询出问题了，结果请求里一看是完全没问题的。印象中代码能工作应该是没问题的，此时陷入了迷惑。")]),t._v(" "),s("h2",{attrs:{id:"_21-9-17注"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_21-9-17注"}},[t._v("#")]),t._v(" 21-9-17注")]),t._v(" "),s("p",[t._v("发现之前写的太模糊了，重新回忆了一下。这个问题应该是，一个需要计算的属性，我只在mounted里面计算了，计算之后的结果单独存进了data里面，组件从data拿到这个数据，从渲染数组中拿到剩下的数据。而之后拉到的新数据中，直接更新了渲染数组，data里面的属性当然就没有更新，导致了这部分信息没变。\n大概是这样，有点忘了，当时怎么也没把代码记一下。")]),t._v(" "),s("h4",{attrs:{id:"前情提要"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前情提要"}},[t._v("#")]),t._v(" 前情提要")]),t._v(" "),s("p",[t._v("学历信息在传输的时候是长度为1的字符，展示的时候需要将其转换为对应的信息便于阅读")]),t._v(" "),s("h4",{attrs:{id:"检查错误"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#检查错误"}},[t._v("#")]),t._v(" 检查错误")]),t._v(" "),s("p",[t._v("直到打开代码一看才发现，之前魔怔地把转换函数写在了mounted里面，将处理结果存在了data对象里，通过mustache调用了结果的信息，显然问题就出在了这里。")]),t._v(" "),s("h4",{attrs:{id:"解决"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决"}},[t._v("#")]),t._v(" 解决")]),t._v(" "),s("p",[t._v("把mustache中的数据换为一个返回处理结果的method函数即可。")]),t._v(" "),s("h4",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("p",[t._v("出现这个问题让我更深一步理解了vue组件的特性，在按条件搜索的时候，展示数组发生了变化，然而仅仅是数组元素中的信息变化了，因此vue并未销毁组件再重新使用新数据创建组件，而仅仅是找出并改变了变化的部分。这才有了学历信息维持不变的问题。")]),t._v(" "),s("p",[t._v("以后编码时需要更加严肃，我是完全会通过函数返回处理数据的，但是却很随便的使用了并不合理的处理方式导致了bug出现。后续需要多加注意代码的合理性。")])])}),[],!1,null,null,null);a.default=r.exports}}]);