(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{425:function(t,a,e){"use strict";e.r(a);var s=e(45),i=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"http缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#http缓存"}},[t._v("#")]),t._v(" HTTP缓存")]),t._v(" "),e("p",[t._v("大致分为强制缓存和对比缓存，是存在浏览器里的缓存。其他web缓存包括数据库缓存，服务器缓存（CDN和代理服务器缓存），Web应用层缓存。HTTP缓存是浏览器缓存中基于http协议实现的，是最常见的缓存。")]),t._v(" "),e("p",[t._v("在首次请求资源的时候，没有缓存文件，后续请求会根据请求头部的缓存策略和缓存的状态（是否过期等）使用缓存中的内容。")]),t._v(" "),e("h2",{attrs:{id:"强制缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[t._v("#")]),t._v(" 强制缓存")]),t._v(" "),e("p",[t._v("对于强制缓存，在无缓存时，返回的数据会带有包含缓存规则的响应头部（Expires/Cache-Control），在符合使用缓存的规则时使用缓存")]),t._v(" "),e("p",[t._v("Expires用于http1.0，而且它不是http1.0一开始就规定的，是后续扩展的规则。现在一般都是http1.1，这已经用的很少了。Expires值表示到期时间，即在这个时间之前再次请求，会使用上一次返回的内容（它已经被缓存了）")]),t._v(" "),e("p",[t._v("Cache-Control是http1.1规定的头部字段之一，常见的取值有private，public，no-cache，max-age，no-store。默认值为private")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("private: 客户端可以缓存\npublic： 客户端和代理服务器都能缓存\nmax-age： 缓存内容有效的秒数\nno-cache：使用对比缓存验证缓存数据\nno-store：所有内容都不会缓存，强制缓存和对比缓存都不会触发\n")])])]),e("p",[t._v("例如：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Cache-Control: max-age=31536000\n")])])]),e("p",[t._v("这样的字段，指定了有效秒数，因此默认为private。表示一年之内都使用缓存")]),t._v(" "),e("h2",{attrs:{id:"对比缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对比缓存"}},[t._v("#")]),t._v(" 对比缓存")]),t._v(" "),e("p",[t._v("需要进行比较判断是否使用缓存。浏览器首次请求数据的时候，服务器会将缓存标识和数据返回给客户端。后续每次请求，客户端将缓存标识发送给服务器，服务器根据缓存标识判断是否允许客户端使用缓存。允许使用缓存时返回304状态码，不允许则使用200并返回需要使用的内容。")]),t._v(" "),e("p",[t._v("允许使用缓存的时候，只返回响应头部。")]),t._v(" "),e("h3",{attrs:{id:"对比缓存标识"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对比缓存标识"}},[t._v("#")]),t._v(" 对比缓存标识")]),t._v(" "),e("h4",{attrs:{id:"last-modified-if-modified-since"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-if-modified-since"}},[t._v("#")]),t._v(" Last-Modified / If-Modified-Since")]),t._v(" "),e("p",[t._v("服务器在响应请求的时候使用Last-Mosified告知浏览器资源的最后修改时间")]),t._v(" "),e("p",[t._v("浏览器再次请求的时候，使用上一次收到的Last-Modified值作为If-Modified-Sience值通知服务器。服务器使用收到的If-Modified-Sience值和资源最后修改时间作对比，如果资源修改时间更大，说明资源改动过，则使用200状态码响应资源内容；否则使用304状态码告知浏览器使用缓存")]),t._v(" "),e("h4",{attrs:{id:"etag-if-none-match"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#etag-if-none-match"}},[t._v("#")]),t._v(" Etag / If-None-Match")]),t._v(" "),e("p",[t._v("此标识优先级高于上面的Modified。")]),t._v(" "),e("p",[t._v("服务器在响应请求的时候使用Etag字段告知浏览器资源在服务器的唯一标识（这个标识是服务器生成的）")]),t._v(" "),e("p",[t._v("浏览器在后续请求的时候使用If-None-Match字段发送先前收到的Etag值，服务器使用收到的值与被请求资源的唯一标识进行比对，如果不同说明资源被修改过，使用200状态码响应资源内容；如果相同说明资源未被修改过，响应304告知浏览器使用缓存")])])}),[],!1,null,null,null);a.default=i.exports}}]);