(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{436:function(e,n,t){"use strict";t.r(n);var a=t(45),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[e._v("#")]),e._v(" 继承")]),e._v(" "),t("p",[e._v("ES的继承主要依靠原型链实现")]),e._v(" "),t("h2",{attrs:{id:"原型链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[e._v("#")]),e._v(" 原型链")]),e._v(" "),t("p",[e._v("令一个原型对象等于另一个类型的实例，就形成了一个原型链。例如：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function SuperType(){\n    this.property = true; \n}\n\nSuperType.prototype.getSuperValue = function(){\n    return this.property;\n}\n\nfunction SubType(){\n    this.subproperty = false;\n}\n\nSubType.prototype = new SuperType();\n//继承了SuperType，此时SubType的原型对象中保存着property\n\nSubType.prototype.getSubValue = function(){\n    return this.subproperty\n}//SubType的原型对象中新增了getSubValue方法\n\nvar instance = new SubType();\nalert(instance.getSuperValue()); //true 因为SubType的原型对象最初是SuperType的实例，拥有指向SuperType原型对象的指针，可以访问SuperType原型对象中的方法\n")])])]),t("p",[e._v("上述代码定义了两个类型：SuperType和SubType。每个类型均有一个属性和方法。instanceof操作符会将instance归类为Object，SuperType，Subtype三者的实例，isPrototypeOf同样")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),t("p",[e._v("子类型添加或重写超类中的方法时，一定要在替换原型的语句之后，另外，使用原型链的时候，不能使用对象字面量，因为会重写原型链。")])]),e._v(" "),t("h2",{attrs:{id:"借用构造函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#借用构造函数"}},[e._v("#")]),e._v(" 借用构造函数")]),e._v(" "),t("p",[e._v("显然，超类的引用类型属性会被每个子类共享。通过在子类构造函数中调用超类构造函数可以解决这个问题：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function  SuperType(){\n    this.colors = ["red", "blue", "green"];\n}\n\n// SubType.prototype = new SuperType();\n// 这会让所有子类共享原型对象中的colors\n\nfunction SubType(){\n    SuperType.call(this);\n}\n//这样每个子类都有自己的colors了\n')])])]),t("h3",{attrs:{id:"传递参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#传递参数"}},[e._v("#")]),e._v(" 传递参数")]),e._v(" "),t("p",[e._v("借用构造函数的时候，可以向超类构造函数传参：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function SuperType(name){\n    this.name = name;\n}\n\nfunction SubType(){\n    SuperType.call(this, "Nicholas");\n    this.age = 29;\n}\n')])])]),t("p",[e._v("借用构造函数时，方法都在构造函数里面定义了，就没办法复用")]),e._v(" "),t("h2",{attrs:{id:"组合继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组合继承"}},[e._v("#")]),e._v(" 组合继承")]),e._v(" "),t("p",[e._v("组合原型链和借用构造函数：使用原型链实现对原型属性和方法的继承，通过借用构造函数来实现对实例属性的继承。这样，即通过在原型上定义方法实现函数复用，又能保证每个实例都有它自己的属性：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function SuperType(name){\n    this.name = name;\n    this.colors = ["red", "blue", "green"];\n}\n\nSuperType.prototype.sayName = function(){\n    alert(this.name);\n}\n\nfunction SubType(name, age){\n    SuperType.call(this.name);\n\n    this.age = age;\n}\n\nSubType.prototype = new SuperType();\nSubType.prototype.sayAge = function(){\n    alert(this.age);\n};\n\nvar instance1 = new SubType("Nicholas", 29);\ninstance1.colors.push("black");\nalert(instance1.colors); //red, blue, green, black\ninstance1.sayName(); // "Nicholas"\ninstance1.sayAge(); // 29\n\nvar instance2 = new SubType("Gerg", 27);\nalert(instance2.colors); // red, blue, green\ninstance2.sayName(); //"Gerg"\ninstance2.sayAge(); // 27\n')])])]),t("p",[e._v("像本例这样，在子类的原型中定义公用方法，结合借用构造函数（超类构造函数的参数在此时传递），让不同的子类拥有自己的引用类型属性。这是最常用的继承模式")])])}),[],!1,null,null,null);n.default=s.exports}}]);