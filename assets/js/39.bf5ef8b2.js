(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{398:function(e,a,t){"use strict";t.r(a);var r=t(45),n=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"对象基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象基础"}},[e._v("#")]),e._v(" 对象基础")]),e._v(" "),t("p",[e._v("对象的属性分为两种类型，数据属性和访问器属性"),t("br"),e._v("\n属性具有一些内部才可用的特征，JS不能直接访问它们")]),e._v(" "),t("h2",{attrs:{id:"数据属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据属性"}},[e._v("#")]),e._v(" 数据属性")]),e._v(" "),t("p",[e._v("数据属性包含了一个数据的位置，在此可以读写其值。数据属性有四个描述其行为的特征：")]),e._v(" "),t("h4",{attrs:{id:"configureable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#configureable"}},[e._v("#")]),e._v(" Configureable")]),e._v(" "),t("p",[e._v("表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否将属性修改为访问器属性。直接在对象上定义的属性，此值默认为true")]),e._v(" "),t("h4",{attrs:{id:"enumable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#enumable"}},[e._v("#")]),e._v(" Enumable")]),e._v(" "),t("p",[e._v("表示能否通过for-in枚举，直接在对象上定义属性，此值默认为true")]),e._v(" "),t("h4",{attrs:{id:"writable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#writable"}},[e._v("#")]),e._v(" Writable")]),e._v(" "),t("p",[e._v("表示能否修改属性的值，直接在对象上定义属性，此值默认为true")]),e._v(" "),t("h4",{attrs:{id:"value"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#value"}},[e._v("#")]),e._v(" Value")]),e._v(" "),t("p",[e._v("这个属性的数据值，保存这属性的值")]),e._v(" "),t("h3",{attrs:{id:"修改特征"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修改特征"}},[e._v("#")]),e._v(" 修改特征")]),e._v(" "),t("p",[e._v("要修改上述四个特征，必须使用**Object.defineProperty()**方法。此方法接收三个参数：属性所在对象，属性的名字和一个描述符对象。其中，描述符对象的属性名需要是上述四个特征的名字：configureable, enumerable, writable和value。例如：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('let person = {};\nObject.defineProperty(person, "name", {\n    writable: false,\n    value: "Nicholas"\n});\n\nalert(person.name);  //Nicholas\nperson.name = "Gerg";\nalert(person.name);  //Nicholas\n')])])]),t("p",[e._v("在非严格模式下，尝试为不可修改的属性指定新值，将什么都不会发生，在严格模式下会出错。对于不可配置的属性也类似。一旦把属性定义为不可配置，它就不能再被改回可配置了，此外，再次调用defineProperty修改除了Writable之外的特性都会产生错误：不能重复定义（"),t("strong",[e._v("这里需要补充一下，红宝书所言是，修改除writable之外的特性会导致产生错误，然而实际上，在writable为true时修改value是没有问题的")]),e._v("）。最后，不指定描述符的情况下，其值默认为false")]),e._v(" "),t("h2",{attrs:{id:"访问器属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#访问器属性"}},[e._v("#")]),e._v(" 访问器属性")]),e._v(" "),t("p",[e._v("不包含数据值，而是一对getter和setter函数，在读取访问器属性时会调用getter函数，写入访问器属性时，会调用setter函数。访问器拥有如下四个特性：")]),e._v(" "),t("h4",{attrs:{id:"configureable-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#configureable-2"}},[e._v("#")]),e._v(" configureable")]),e._v(" "),t("p",[e._v("与数据属性的特征相同，表示能否通过删除属性从而重新定义属性，或能否将属性修改为数据属性。直接在对象上定义的属性，这个特征的默认值为true")]),e._v(" "),t("h4",{attrs:{id:"enumerable"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#enumerable"}},[e._v("#")]),e._v(" enumerable")]),e._v(" "),t("p",[e._v("能否通过for-in枚举此属性")]),e._v(" "),t("h4",{attrs:{id:"get"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get"}},[e._v("#")]),e._v(" get")]),e._v(" "),t("p",[e._v("读取属性时调用的函数，默认值为undefined")]),e._v(" "),t("h4",{attrs:{id:"set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[e._v("#")]),e._v(" set")]),e._v(" "),t("p",[e._v("写入属性时调用的函数，默认值为undefined")]),e._v(" "),t("h3",{attrs:{id:"定义访问器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义访问器"}},[e._v("#")]),e._v(" 定义访问器")]),e._v(" "),t("p",[e._v("访问器属性不能直接定义，必须使用Object.defineProperty()来定义：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('var book = {\n    _year: 2004,\n    edition: 1\n};\n\nObject.defineProperty(book, "year", {\n    get: function(){\n        return this._year;\n    },\n    set: function(newVal){\n        if(newVal > 2004){\n            this._year = newVal;\n            this.edition += newVal - 2004;\n        }\n    }\n})\n')])])]),t("p",[e._v("以上代码创建了一个book对象，定义了两个默认属性_year和edition（_year前的下划线是一种常用记号，表示只能通过对象方法访问这个属性。而访问器属性year则包含getter和setter函数，这是访问器属性的常见用法，即设置一个属性时会导致其他属性发生变化")]),e._v(" "),t("h2",{attrs:{id:"定义多个属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定义多个属性"}},[e._v("#")]),e._v(" 定义多个属性")]),e._v(" "),t("p",[e._v("Object.defineProperties()用于一次性定义多个属性。接收两个对象参数，第一个对象时要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应，听起来很复杂，通过一个例子来说明：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var book = {};\n\nObject.defineProperties(book, {\n    _year: {\n        value: 2004\n    },\n\n    edition: {\n        value: 1\n    },\n    year: {\n        get: function(){\n            return this._year;\n        },\n        set: function(newVal){\n            if(newVal > 2004){\n                this._year = newVal;\n                this.edition += newVal - 2004;\n            }\n        }\n    }\n});\n")])])]),t("p",[e._v("上述代码定义了与上一个例子相同的book对象")]),e._v(" "),t("h2",{attrs:{id:"读取属性的特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#读取属性的特性"}},[e._v("#")]),e._v(" 读取属性的特性")]),e._v(" "),t("p",[e._v("Object.getOwnPropertyDescriptor()用于取得给定属性的描述符，它接收两个参数，属性所在对象和要读取的属性名称。将会返回一个对象，包含属性名为各特性的值")])])}),[],!1,null,null,null);a.default=n.exports}}]);